import { evaluate as K } from "@strudel/core";
import { getLeafLocations as $ } from "@strudel/mini";
import { parse as O } from "acorn";
import D from "escodegen";
import { walk as N } from "estree-walker";
let P = [];
function Ee(e) {
  P.push(e);
}
let E = /* @__PURE__ */ new Map();
function we(e, t) {
  E.set(e, t);
}
function F(e, t = {}) {
  const { wrapAsync: n = !1, addReturn: a = !0, emitMiniLocations: i = !0, emitWidgets: p = !0 } = t, f = [];
  let l = O(e, {
    ecmaVersion: 2022,
    allowAwaitOutsideFunction: !0,
    locations: !0,
    onComment: f
  });
  const m = ce(f, e.length);
  let c = [];
  const b = (r, x) => {
    const s = E.get("minilang");
    if (s) {
      const u = `[${r}]`, o = s.getLocations(u, x.start);
      c = c.concat(o);
    } else {
      const u = $(`"${r}"`, x.start, e);
      c = c.concat(u);
    }
  };
  let y = [];
  N(l, {
    enter(r, x) {
      if (se(r)) {
        const { name: s } = r.tag, u = E.get(s), o = r.quasi.quasis[0].value.raw, h = r.quasi.start + 1;
        if (i) {
          const C = u.getLocations(o, h);
          c = c.concat(C);
        }
        return this.skip(), this.replace(ue(s, o, h));
      }
      if (le(r, "tidal")) {
        const s = r.quasi.quasis[0].value.raw, u = r.quasi.start + 1;
        if (i) {
          const o = oe(s, u);
          c = c.concat(o);
        }
        return this.skip(), this.replace(pe(s, u));
      }
      if (U(r, x)) {
        if (q(r.start, m))
          return;
        const { quasis: s } = r, { raw: u } = s[0].value;
        return this.skip(), i && b(u, r), this.replace(T(u, r));
      }
      if (G(r)) {
        if (q(r.start, m))
          return;
        const { value: s } = r;
        return this.skip(), i && b(s, r), this.replace(T(s, r));
      }
      if (X(r))
        return p && y.push({
          from: r.arguments[0].start,
          to: r.arguments[0].end,
          value: r.arguments[0].raw,
          // don't use value!
          min: r.arguments[1]?.value ?? 0,
          max: r.arguments[2]?.value ?? 1,
          step: r.arguments[3]?.value,
          type: "slider"
        }), this.replace(Z(r));
      if (Y(r)) {
        const s = r.callee.property.name, u = y.filter((h) => h.type === s).length, o = {
          to: r.end,
          index: u,
          type: s,
          id: t.id
        };
        return p && y.push(o), this.replace(te(r, o));
      }
      if (re(r, x))
        return this.replace(ne(r));
      if (ie(r))
        return this.replace(ae(r));
    },
    leave(r, x, s, u) {
      if (!R(r)) return;
      let [o, ...h] = r.arguments;
      if (!o) throw new Error("K(...) requires an expression");
      _(o) && (o = {
        type: "CallExpression",
        callee: o,
        arguments: [],
        optional: !1
      });
      const { template: C, patternExprs: k } = B(o);
      if (k.length) {
        const d = [{ type: "Literal", value: C }, ...k, ...h];
        let L = r.callee;
        return L.type === "ChainExpression" && (L = L.expression), L.type === "MemberExpression" ? this.replace({
          type: "CallExpression",
          callee: W(L.object),
          arguments: d,
          optional: !1
        }) : this.replace({
          type: "CallExpression",
          callee: { type: "Identifier", name: "worklet" },
          arguments: d,
          optional: !1
        });
      }
      const M = [{ type: "Literal", value: S(o) }, ...h];
      let w = r.callee;
      return w.type === "ChainExpression" && (w = w.expression), w.type === "MemberExpression" ? this.replace({
        type: "CallExpression",
        callee: W(w.object),
        arguments: M,
        optional: !1
      }) : this.replace({
        type: "CallExpression",
        callee: { type: "Identifier", name: "worklet" },
        arguments: M,
        optional: !1
      });
    }
  });
  let { body: g } = l;
  if (!g.length)
    console.warn("empty body -> fallback to silence"), g.push({
      type: "ExpressionStatement",
      expression: {
        type: "Identifier",
        name: "silence"
      }
    });
  else if (!g?.[g.length - 1]?.expression)
    throw new Error("unexpected ast format without body expression");
  if (a) {
    const { expression: r } = g[g.length - 1];
    g[g.length - 1] = {
      type: "ReturnStatement",
      argument: r
    };
  }
  let v = D.generate(l);
  return n && (v = `(async ()=>{${v}})()`), i ? { output: v, miniLocations: c, widgets: y } : { output: v };
}
function R(e) {
  if (e.type !== "CallExpression") return !1;
  let t = e.callee;
  return t.type === "ChainExpression" && (t = t.expression), t.type === "MemberExpression" ? !t.computed && t.property?.name === "K" : t.type === "Identifier" && t.name === "K";
}
function _(e) {
  return e.type !== "ArrowFunctionExpression" && e.type !== "FunctionExpression" || e.params.length ? !1 : e.body?.type === "BlockStatement";
}
function S(e) {
  return D.generate(e, { format: { semicolons: !1 } });
}
function B(e) {
  const t = I(e), n = /* @__PURE__ */ new Map(), a = [];
  if (N(t, {
    enter(l, m, c, b) {
      n.set(l, { parent: m, prop: c, index: b });
      const y = J(l);
      y && (a.push({ node: l, patternExpr: y }), this.skip());
    }
  }), !a.length)
    return { template: S(t), patternExprs: [] };
  a.sort((l, m) => A(l.node) - A(m.node));
  const i = a.map(({ patternExpr: l }) => I(l));
  let p = t;
  return a.forEach(({ node: l }, m) => {
    p = z(l, V(m), n, p);
  }), { template: S(p), patternExprs: i };
}
function J(e) {
  if (H(e)) {
    const t = e.arguments?.[0];
    if (!t)
      throw new Error("S(...) requires an argument");
    return t;
  }
  return j(e) ? e : null;
}
function H(e) {
  if (e.type !== "CallExpression")
    return !1;
  const t = e.callee;
  return t.type === "Identifier" ? t.name === "S" : t.type === "MemberExpression" && !t.computed ? t.property?.name === "S" : !1;
}
function Q() {
  return E.get("minilang")?.name || "m";
}
function j(e) {
  if (e.type !== "CallExpression")
    return !1;
  const t = e.callee;
  if (t.type !== "Identifier" || t.name !== Q())
    return !1;
  const n = e.arguments?.[0];
  return n?.type === "Literal" && typeof n.value == "string";
}
function A(e) {
  if (typeof e.start == "number")
    return e.start;
  if (j(e)) {
    const t = e.arguments?.[1];
    if (t?.type === "Literal" && typeof t.value == "number")
      return t.value;
  }
  return 0;
}
function V(e) {
  return {
    type: "MemberExpression",
    object: { type: "Identifier", name: "pat" },
    property: { type: "Literal", value: e },
    computed: !0,
    optional: !1
  };
}
function z(e, t, n, a) {
  const i = n.get(e);
  if (!i || !i.parent)
    return t;
  const { parent: p, prop: f, index: l } = i;
  return Array.isArray(p[f]) ? p[f][l] = t : p[f] = t, n.set(t, { parent: p, prop: f, index: l }), a;
}
function I(e) {
  return JSON.parse(JSON.stringify(e));
}
function W(e) {
  return {
    type: "MemberExpression",
    object: e,
    property: { type: "Identifier", name: "worklet" },
    computed: !1,
    optional: !1
  };
}
function G(e, t, n) {
  return e.type !== "Literal" ? !1 : e.raw[0] === '"';
}
function U(e, t) {
  return e.type === "TemplateLiteral" && t.type !== "TaggedTemplateExpression";
}
function T(e, t) {
  const { start: n } = t, a = E.get("minilang");
  let i = "m";
  return a && a.name && (i = a.name), {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: i
    },
    arguments: [
      { type: "Literal", value: e },
      { type: "Literal", value: n }
    ],
    optional: !1
  };
}
function X(e) {
  return e.type === "CallExpression" && e.callee.name === "slider";
}
function Y(e) {
  return e.type === "CallExpression" && P.includes(e.callee.property?.name);
}
function Z(e) {
  const t = "slider_" + e.arguments[0].start;
  return e.arguments.unshift({
    type: "Literal",
    value: t,
    raw: t
  }), e.callee.name = "sliderWithID", e;
}
function ee(e) {
  return `${e.id || ""}_widget_${e.type}_${e.index}`;
}
function te(e, t) {
  const n = ee(t);
  return e.arguments.unshift({
    type: "Literal",
    value: n,
    raw: n
  }), e;
}
function re(e, t) {
  return e.type === "CallExpression" && e.callee.name === "samples" && t.type !== "AwaitExpression";
}
function ne(e) {
  return {
    type: "AwaitExpression",
    argument: e
  };
}
function ie(e) {
  return e.type === "LabeledStatement";
}
function ae(e) {
  return {
    type: "ExpressionStatement",
    expression: {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: e.body.expression,
        property: {
          type: "Identifier",
          name: "p"
        }
      },
      arguments: [
        {
          type: "Literal",
          value: e.label.name,
          raw: `'${e.label.name}'`
        }
      ]
    }
  };
}
function se(e) {
  return e.type === "TaggedTemplateExpression" && E.has(e.tag.name);
}
function le(e, t) {
  return e.type === "TaggedTemplateExpression" && e.tag.name === t;
}
function oe(e, t) {
  return e.split("").reduce((n, a, i) => (a !== '"' || (!n.length || n[n.length - 1].length > 1 ? n.push([i + 1]) : n[n.length - 1].push(i)), n), []).map(([n, a]) => {
    const i = e.slice(n, a);
    return $(`"${i}"`, t + n - 1);
  }).flat();
}
function pe(e, t) {
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: "tidal"
    },
    arguments: [
      { type: "Literal", value: e },
      { type: "Literal", value: t }
    ],
    optional: !1
  };
}
function ue(e, t, n) {
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: e
    },
    arguments: [
      { type: "Literal", value: t },
      { type: "Literal", value: n }
    ],
    optional: !1
  };
}
function ce(e, t) {
  const n = [], a = [];
  for (const i of e) {
    const p = i.value.trim();
    if (p.startsWith("mini-off"))
      a.push(i.start);
    else if (p.startsWith("mini-on")) {
      const f = a.pop();
      n.push([f, i.end]);
    }
  }
  for (; a.length; ) {
    const i = a.pop();
    n.push([i, t]);
  }
  return n;
}
function q(e, t) {
  for (const [n, a] of t)
    if (e >= n && e < a)
      return !0;
  return !1;
}
const Le = (e) => K(e, F);
export {
  Le as evaluate,
  ee as getWidgetID,
  we as registerLanguage,
  Ee as registerWidgetType,
  F as transpiler
};
