var kabelsalat=function(r){"use strict";class o{constructor(e,n){this.type=e,n!==void 0&&(this.value=n),this.ins=[]}static parseInput(e,n){if(typeof e=="function"){if(!n)throw new Error("tried to parse function input without without passing node..");return e(n)}return typeof e=="object"?e:typeof e=="number"&&!isNaN(e)||typeof e=="string"?g(e):(console.log(`invalid input type "${typeof e}" for node of type "${n.type}", falling back to 0. The input was:`,e),0)}}const y=(t,e)=>new o(t,e);let l=new Map;const h="poly",w="exit";o.prototype.inherit=function(t){return t.inputOf&&(this.inputOf=t.inputOf),t.outputOf&&(this.outputOf=t.outputOf),this},o.prototype.toObject=function(){return JSON.parse(JSON.stringify(this))},o.prototype.stringify=function(){return JSON.stringify(this,null,2).replaceAll('"',"'")};function b(t,...e){let n=1;if(e=e.map(i=>{if(Array.isArray(i)){if(i.length===1)return i[0];i=new o(h).withIns(...i)}if(typeof i=="function"){const u=i(new o("peek"));u.type===h&&(n=Math.max(u.ins.length,n))}return i.type===h&&(n=Math.max(i.ins.length,n)),i}),n===1){const i=y(t);return i.withIns(...e.map(u=>o.parseInput(u,i)))}if(t===w){const i=e.map(u=>u.type===h?u.ins.map(a=>o.parseInput(a).inherit(a)):u).flat();return y(w).withIns(...i)}const s=Array.from({length:n},(i,u)=>{const a=new o(t),O=e.map(c=>c.type===h?o.parseInput(c.ins[u%c.ins.length],a).inherit(c):(c=o.parseInput(c,a),c.type===h&&(c=c.ins[u]),c));return a.withIns(...O)});return new o(h).withIns(...s)}function A(t,e){const n=l.get(t);return n?.ins?.[e]?n.ins[e].name:""}let I=(t,e)=>m(t,(...n)=>b(t,...n),e);l.set("register",{tags:["meta"],graph:!1,description:"Registers a new Node function. Sets it on the prototype + returns the function itself. Like `module` but doesn't hide complexity in graph viz.",examples:[`let kick = register('kick', gate => gate.adsr(0,.11,0,.11)
.apply(env => env.mul(env)
  .mul(158)
  .sine(env)
  .distort(.85)
))
impulse(2).kick().out()`]});let m=(t,e,n)=>(n&&l.set(t,n),o.prototype[t]=function(...s){return e(this,...s)},o.prototype["_"+t]=function(){return this},e);l.set("module",{tags:["meta"],graph:!0,description:"Creates a module. Like `register`, but the graph viz will hide the internal complexity of the module.",examples:[`let kick = module('kick', gate => gate.adsr(0,.11,0,.11)
.apply(env => env.mul(env)
  .mul(158)
  .sine(env)
  .distort(.85)
))
impulse(2).kick().out()`]});let R=0;function F(t,e,n){return m(t,(...s)=>{const i=R++;return s=s.map((u,a)=>o.parseInput(u).asModuleInput?.(t,i,a)),e(...s).asModuleOutput?.(t,i)},n)}l.set("n",{tags:["math"],description:"Constant value node. Turns a number into a Node.",ins:[{name:"value",default:0}]});function g(t){return Array.isArray(t)?poly(...t.map(e=>g(e))):typeof t=="object"?t:y("n",t)}l.set("out",{tags:["meta"],description:"Sends the node to the audio output"}),l.set("withIns",{internal:!0,tags:["innards"],description:"Sets the inputs of a node. Returns the node itself",ins:[{name:"in",dynamic:!0}]}),o.prototype.withIns=function(...t){return this.ins=t,this},l.set("flatten",{internal:!0,tags:["innards"],description:"Flattens the node to a list of all nodes in the graph, where each Node's ins are now indices"}),o.prototype.flatten=function(){return q(this)},l.set("apply",{graph:!0,tags:["meta"],description:"Applies the given function to the Node. Useful when a node has to be used multiple times.",examples:[`impulse(4)
.apply(imp=>imp
  .seq(110,220,330,440)
  .sine()
  .mul( imp.ad(.1,.1) )
).out()`]}),o.prototype.apply=function(t){return t(this)},l.set("clone",{internal:!0,tags:["innards"],description:"Clones the node"}),o.prototype.clone=function(){return new o(this.type,this.value).withIns(...this.ins)},l.set("map",{tags:["meta"],description:"Applies the given function to all ins if it's poly node. Otherwise it applies the function to itself.",examples:[`n([110,220,330])
.map( freq=>freq.mul([1,1.007]).saw().mix() )
.mix(2).mul(.5).out()`]}),o.prototype.map=function(t){return this.type!=="poly"?t(this):poly(...this.ins.map(t))},o.prototype.channel=function(t){return this.type!=="poly"?this:this.ins[t%this.ins.length]},l.set("select",{tags:["meta"],graph:!0,description:"Find the first occurence of the given type up in the graph and returns the match. Useful to exit a feedback loop at another point.",examples:[`sine(220).mul(impulse(1).ad(.001,.2))
.add( x=>x.delay(.2).mul(.8) )
.select('delay').out()
`]}),o.prototype.select=function(t){for(let e of this.ins){if(e.type===t)return e;const n=e.select(t);if(n)return n}},l.set("debug",{tags:["meta"],description:"Logs the node to the console"}),o.prototype.debug=function(t=e=>e){return console.log(t(this)),this};function J(t){const e=modules.get(t),n=Array.from({length:e.length},(i,u)=>y(`$INPUT${u}`)),s=e(...n);return JSON.stringify(s,null,2)}function q(t){const e=[];return v(t,n=>(e.push(n),n)),e.map(n=>{let s={...n,type:n.type,ins:n.ins.map(i=>e.indexOf(i)+"")};return n.value!==void 0&&(s.value=n.value),n.to!==void 0&&(s.to=e.indexOf(n.to)),s})}let N=I("exit",{internal:!0});function C(t,e){let n=[];const s=m("out",function(u,a=[0,1]){return n.push(u.output(a)),u});return e?(e.out=s,Function(...Object.keys(e),t)(...Object.values(e))):(globalThis.out=s,Function(t)()),N(...n)}o.prototype.over=function(t){return this.apply(e=>add(e,t(e)))},o.prototype.dfs=function(t,e){return this.apply(n=>v(n,t,e))},o.prototype.apply2=function(t){return t(this,this)};let v=(t,e,n=[])=>(t=e(t,n),n.push(t),t.ins=t.ins.map(s=>n.includes(s)?s:v(s,e,n)),t);o.prototype.asModuleInput=function(t,e,n){return this.inputOf=this.inputOf||[],this.inputOf.push([t,e,n]),this},o.prototype.asModuleOutput=function(t,e){return this.outputOf=[t,e],this};function S(t,e={}){const{log:n=!1,lang:s="js",fallbackType:i="thru",constType:u="n",getRegister:a=p=>`r[${p}]`,getOutput:O=p=>`o[${p}]`,getSource:c=p=>`s[${p}]`}=e;n&&console.log("compile",t);const f=L(t);let x=[],T=p=>f[p].type!==u?a(p):typeof f[p].value=="string"?`"${f[p].value}"`:f[p].value;const k=[];for(let p in f){const $=f[p],j=f[p].ins.map(z=>T(f.indexOf(z))),U=k.length;let d=l.get($.type);d||(console.warn(`unhandled node type "${f[p].type}". falling back to "${i}"`),d=l.get(i));const _={vars:j,node:$,nodes:f,id:p,ugenIndex:U,ugen:d.ugen,name:T(p),lang:s,getRegister:a,getOutput:O,getSource:c};d.compile&&x.push(d.compile(_)),d.ugen&&k.push({type:d.ugen,inputs:j})}const M=x.join(`
`);return n&&(console.log("compiled code:"),console.log(M)),{src:M,ugens:k,registers:f.length}}o.prototype.compile=function(t){return S(this,t)};function L(t){const e=[],n=new Set;function s(i){if(!(typeof i!="object"||n.has(i))){n.add(i);for(let u in i.ins)s(i.ins[u]);e.push(i)}}return s(t),e}return r.Node=o,r.compile=S,r.evaluate=C,r.exit=N,r.exportModule=J,r.getInletName=A,r.getNode=b,r.module=F,r.n=g,r.node=y,r.nodeRegistry=l,r.outputType=w,r.polyType=h,r.register=m,r.registerNode=I,Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),r}({});
